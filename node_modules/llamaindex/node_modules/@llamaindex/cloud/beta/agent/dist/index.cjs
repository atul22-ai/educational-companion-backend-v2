Object.defineProperty(exports, '__esModule', { value: true });

var env = require('@llamaindex/env');

var A = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
}, R = {
    bodySerializer: (t)=>JSON.stringify(t, (r, e)=>typeof e == "bigint" ? e.toString() : e)
}, U = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, _ = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, O = ({ allowReserved: t, explode: r, name: e, style: a, value: i })=>{
    if (!r) {
        let s = (t ? i : i.map((l)=>encodeURIComponent(l))).join(_(a));
        switch(a){
            case "label":
                return `.${s}`;
            case "matrix":
                return `;${e}=${s}`;
            case "simple":
                return s;
            default:
                return `${e}=${s}`;
        }
    }
    let o = U(a), n = i.map((s)=>a === "label" || a === "simple" ? t ? s : encodeURIComponent(s) : y({
            allowReserved: t,
            name: e,
            value: s
        })).join(o);
    return a === "label" || a === "matrix" ? o + n : n;
}, y = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
}, q = ({ allowReserved: t, explode: r, name: e, style: a, value: i })=>{
    if (i instanceof Date) return `${e}=${i.toISOString()}`;
    if (a !== "deepObject" && !r) {
        let s = [];
        Object.entries(i).forEach(([f, u])=>{
            s = [
                ...s,
                f,
                t ? u : encodeURIComponent(u)
            ];
        });
        let l = s.join(",");
        switch(a){
            case "form":
                return `${e}=${l}`;
            case "label":
                return `.${l}`;
            case "matrix":
                return `;${e}=${l}`;
            default:
                return l;
        }
    }
    let o = D(a), n = Object.entries(i).map(([s, l])=>y({
            allowReserved: t,
            name: a === "deepObject" ? `${e}[${s}]` : s,
            value: l
        })).join(o);
    return a === "label" || a === "matrix" ? o + n : n;
};
var H = /\{[^{}]+\}/g, B = ({ path: t, url: r })=>{
    let e = r, a = r.match(H);
    if (a) for (let i of a){
        let o = false, n = i.substring(1, i.length - 1), s = "simple";
        n.endsWith("*") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(".") ? (n = n.substring(1), s = "label") : n.startsWith(";") && (n = n.substring(1), s = "matrix");
        let l = t[n];
        if (l == null) continue;
        if (Array.isArray(l)) {
            e = e.replace(i, O({
                explode: o,
                name: n,
                style: s,
                value: l
            }));
            continue;
        }
        if (typeof l == "object") {
            e = e.replace(i, q({
                explode: o,
                name: n,
                style: s,
                value: l
            }));
            continue;
        }
        if (s === "matrix") {
            e = e.replace(i, `;${y({
                name: n,
                value: l
            })}`);
            continue;
        }
        let f = encodeURIComponent(s === "label" ? `.${l}` : l);
        e = e.replace(i, f);
    }
    return e;
}, P = ({ allowReserved: t, array: r, object: e } = {})=>(i)=>{
        let o = [];
        if (i && typeof i == "object") for(let n in i){
            let s = i[n];
            if (s != null) if (Array.isArray(s)) {
                let l = O({
                    allowReserved: t,
                    explode: true,
                    name: n,
                    style: "form",
                    value: s,
                    ...r
                });
                l && o.push(l);
            } else if (typeof s == "object") {
                let l = q({
                    allowReserved: t,
                    explode: true,
                    name: n,
                    style: "deepObject",
                    value: s,
                    ...e
                });
                l && o.push(l);
            } else {
                let l = y({
                    allowReserved: t,
                    name: n,
                    value: s
                });
                l && o.push(l);
            }
        }
        return o.join("&");
    }, E = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
}, I = async ({ security: t, ...r })=>{
    for (let e of t){
        let a = await A(e, r.auth);
        if (!a) continue;
        let i = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[i] = a;
                break;
            case "cookie":
                r.headers.append("Cookie", `${i}=${a}`);
                break;
            case "header":
            default:
                r.headers.set(i, a);
                break;
        }
        return;
    }
}, S = (t)=>W({
        baseUrl: t.baseUrl,
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : P(t.querySerializer),
        url: t.url
    }), W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i })=>{
    let o = i.startsWith("/") ? i : `/${i}`, n = (t ?? "") + o;
    r && (n = B({
        path: r,
        url: n
    }));
    let s = e ? a(e) : "";
    return s.startsWith("?") && (s = s.substring(1)), s && (n += `?${s}`), n;
}, C = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;
}, x = (...t)=>{
    let r = new Headers;
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let a = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [i, o] of a)if (o === null) r.delete(i);
        else if (Array.isArray(o)) for (let n of o)r.append(i, n);
        else o !== void 0 && r.set(i, typeof o == "object" ? JSON.stringify(o) : o);
    }
    return r;
}, h = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    exists(r) {
        return this._fns.indexOf(r) !== -1;
    }
    eject(r) {
        let e = this._fns.indexOf(r);
        e !== -1 && (this._fns = [
            ...this._fns.slice(0, e),
            ...this._fns.slice(e + 1)
        ]);
    }
    use(r) {
        this._fns = [
            ...this._fns,
            r
        ];
    }
}, v = ()=>({
        error: new h,
        request: new h,
        response: new h
    }), N = P({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
}), Q = {
    "Content-Type": "application/json"
}, w = (t = {})=>({
        ...R,
        headers: Q,
        parseAs: "auto",
        querySerializer: N,
        ...t
    });
var J = (t = {})=>{
    let r = C(w(), t), e = ()=>({
            ...r
        }), a = (n)=>(r = C(r, n), e()), i = v(), o = async (n)=>{
        let s = {
            ...r,
            ...n,
            fetch: n.fetch ?? r.fetch ?? globalThis.fetch,
            headers: x(r.headers, n.headers)
        };
        s.security && await I({
            ...s,
            security: s.security
        }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
        let l = S(s), f = {
            redirect: "follow",
            ...s
        }, u = new Request(l, f);
        for (let p of i.request._fns)u = await p(u, s);
        let T = s.fetch, c = await T(u);
        for (let p of i.response._fns)c = await p(c, u, s);
        let m = {
            request: u,
            response: c
        };
        if (c.ok) {
            if (c.status === 204 || c.headers.get("Content-Length") === "0") return {
                data: {},
                ...m
            };
            let p = (s.parseAs === "auto" ? E(c.headers.get("Content-Type")) : s.parseAs) ?? "json";
            if (p === "stream") return {
                data: c.body,
                ...m
            };
            let b = await c[p]();
            return p === "json" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), {
                data: b,
                ...m
            };
        }
        let g = await c.text();
        try {
            g = JSON.parse(g);
        } catch  {}
        let d = g;
        for (let p of i.error._fns)d = await p(g, c, u, s);
        if (d = d || {}, s.throwOnError) throw d;
        return {
            error: d,
            ...m
        };
    };
    return {
        buildUrl: S,
        connect: (n)=>o({
                ...n,
                method: "CONNECT"
            }),
        delete: (n)=>o({
                ...n,
                method: "DELETE"
            }),
        get: (n)=>o({
                ...n,
                method: "GET"
            }),
        getConfig: e,
        head: (n)=>o({
                ...n,
                method: "HEAD"
            }),
        interceptors: i,
        options: (n)=>o({
                ...n,
                method: "OPTIONS"
            }),
        patch: (n)=>o({
                ...n,
                method: "PATCH"
            }),
        post: (n)=>o({
                ...n,
                method: "POST"
            }),
        put: (n)=>o({
                ...n,
                method: "PUT"
            }),
        request: o,
        setConfig: a,
        trace: (n)=>o({
                ...n,
                method: "TRACE"
            })
    };
};

// This file is auto-generated by @hey-api/openapi-ts
const client = J(w());

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Delete Agent Data
 * Delete agent data by ID.
 */ const deleteAgentDataApiV1BetaAgentDataItemIdDelete = (options)=>{
    return (options.client ?? client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options
    });
};
/**
 * Get Agent Data
 * Get agent data by ID.
 */ const getAgentDataApiV1BetaAgentDataItemIdGet = (options)=>{
    return (options.client ?? client).get({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options
    });
};
/**
 * Update Agent Data
 * Update agent data by ID (overwrites).
 */ const updateAgentDataApiV1BetaAgentDataItemIdPut = (options)=>{
    return (options.client ?? client).put({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/{item_id}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Create Agent Data
 * Create new agent data.
 */ const createAgentDataApiV1BetaAgentDataPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Search Agent Data
 * Search agent data with filtering, sorting, and pagination.
 */ const searchAgentDataApiV1BetaAgentDataSearchPost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:search",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};
/**
 * Aggregate Agent Data
 * Aggregate agent data with grouping and optional counting/first item retrieval.
 */ const aggregateAgentDataApiV1BetaAgentDataAggregatePost = (options)=>{
    return (options.client ?? client).post({
        security: [
            {
                scheme: "bearer",
                type: "http"
            },
            {
                scheme: "bearer",
                type: "http"
            }
        ],
        url: "/api/v1/beta/agent-data/:aggregate",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers
        }
    });
};

/**
 * Async client for agent data operations
 */ class AgentClient {
    constructor({ apiKey = env.getEnv("LLAMA_CLOUD_API_KEY"), baseUrl = "https://api.cloud.llamaindex.ai/", collection = "default", agentUrlId = "default" }){
        this.baseUrl = baseUrl;
        this.headers = {
            "X-SDK-Name": "llamaindex-ts",
            ...apiKey && {
                Authorization: `Bearer ${apiKey}`
            }
        };
        this.client = J(w({
            baseUrl: this.baseUrl,
            headers: this.headers
        }));
        this.collection = collection;
        this.agentUrlId = agentUrlId;
    }
    /**
   * Create new agent data
   */ async createItem(data) {
        const response = await createAgentDataApiV1BetaAgentDataPost({
            throwOnError: true,
            body: {
                agent_slug: this.agentUrlId,
                collection: this.collection,
                data: data
            },
            client: this.client
        });
        return this.transformResponse(response.data);
    }
    /**
   * Get agent data by ID
   */ async getItem(id) {
        try {
            const response = await getAgentDataApiV1BetaAgentDataItemIdGet({
                throwOnError: true,
                path: {
                    item_id: id
                },
                client: this.client
            });
            return this.transformResponse(response.data);
        } catch (error) {
            if (error instanceof Error && "response" in error && error.response?.status === 404) {
                return null;
            }
            throw error;
        }
    }
    /**
   * Update agent data
   */ async updateItem(id, data) {
        const response = await updateAgentDataApiV1BetaAgentDataItemIdPut({
            throwOnError: true,
            path: {
                item_id: id
            },
            body: {
                data: data
            },
            client: this.client
        });
        return this.transformResponse(response.data);
    }
    /**
   * Delete agent data
   */ async deleteItem(id) {
        await deleteAgentDataApiV1BetaAgentDataItemIdDelete({
            throwOnError: true,
            path: {
                item_id: id
            },
            client: this.client
        });
    }
    /**
   * List agent data
   */ async search(options) {
        const response = await searchAgentDataApiV1BetaAgentDataSearchPost({
            throwOnError: true,
            body: {
                agent_slug: this.agentUrlId,
                ...this.collection !== undefined && {
                    collection: this.collection
                },
                ...options.filter !== undefined && {
                    filter: options.filter
                },
                ...options.orderBy !== undefined && {
                    order_by: options.orderBy
                },
                ...options.pageSize !== undefined && {
                    page_size: options.pageSize
                },
                ...options.offset !== undefined && {
                    offset: options.offset
                },
                ...options.includeTotal !== undefined && {
                    include_total: options.includeTotal
                }
            },
            client: this.client
        });
        const result = {
            items: response.data.items.map((item)=>this.transformResponse(item))
        };
        if (response.data.total_size !== null && response.data.total_size !== undefined) {
            result.totalSize = response.data.total_size;
        }
        if (response.data.next_page_token !== null && response.data.next_page_token !== undefined) {
            result.nextPageToken = response.data.next_page_token;
        }
        return result;
    }
    /**
   * Aggregate agent data into groups
   */ async aggregate(options) {
        const response = await aggregateAgentDataApiV1BetaAgentDataAggregatePost({
            throwOnError: true,
            body: {
                agent_slug: this.agentUrlId,
                ...this.collection !== undefined && {
                    collection: this.collection
                },
                ...options.filter !== undefined && {
                    filter: options.filter
                },
                ...options.groupBy !== undefined && {
                    group_by: options.groupBy
                },
                ...options.count !== undefined && {
                    count: options.count
                },
                ...options.first !== undefined && {
                    first: options.first
                },
                ...options.orderBy !== undefined && {
                    order_by: options.orderBy
                },
                ...options.offset !== undefined && {
                    offset: options.offset
                },
                ...options.pageSize !== undefined && {
                    page_size: options.pageSize
                }
            },
            client: this.client
        });
        const result = {
            items: response.data.items.map((item)=>this.transformAggregateResponse(item))
        };
        if (response.data.total_size !== null && response.data.total_size !== undefined) {
            result.totalSize = response.data.total_size;
        }
        if (response.data.next_page_token !== null && response.data.next_page_token !== undefined) {
            result.nextPageToken = response.data.next_page_token;
        }
        return result;
    }
    /**
   * Transform API response to typed data
   */ transformResponse(data) {
        const result = {
            id: data.id,
            agentUrlId: data.agent_slug,
            data: data.data,
            createdAt: new Date(data.created_at),
            updatedAt: new Date(data.updated_at)
        };
        if (data.collection !== undefined) {
            result.collection = data.collection;
        }
        return result;
    }
    /**
   * Transform API aggregate response to typed data
   */ transformAggregateResponse(data) {
        const result = {
            groupKey: data.group_key
        };
        if (data.count !== null && data.count !== undefined) {
            result.count = data.count;
        }
        if (data.first_item !== null && data.first_item !== undefined) {
            result.firstItem = data.first_item;
        }
        return result;
    }
}
/**
 * Create a new AsyncAgentDataClient instance
 * @param options - The options for the client
 * @returns A new AgentClient instance
 */ function createAgentDataClient({ apiKey, baseUrl, windowUrl, agentUrlId, collection = "default" } = {}) {
    if (windowUrl && !agentUrlId) {
        try {
            const path = new URL(windowUrl).pathname;
            // /deployments/<agent-url-id>/ui/ -> ["", "deployments", "<agent-url-id>", "ui"]
            agentUrlId = path.split("/")[2];
        } catch (error) {
            console.warn("Failed to infer agent url id from window url, falling back to default", error);
        }
    }
    return new AgentClient({
        ...apiKey && {
            apiKey
        },
        ...baseUrl && {
            baseUrl
        },
        ...agentUrlId && {
            agentUrlId
        },
        collection
    });
}

/**
 * Status types for agent data processing
 */ const StatusType = {
    ERROR: "error",
    ACCEPTED: "accepted",
    REJECTED: "rejected",
    PENDING_REVIEW: "pending_review"
};

exports.AgentClient = AgentClient;
exports.StatusTypeEnum = StatusType;
exports.createAgentDataClient = createAgentDataClient;
